# palindromic-sequence
## 回文串类问题

● 647. 回文子串

两种做法，中心扩散或者dp，

中心扩散法的话就要把扩散分为奇数长度扩散和偶数长度扩散。

dp的话记得第一遍倒序，然后第二遍从i开头到len，只要i==j比对上，那么代表找到可能回文串的头和尾，那么如果长度小于等于1，直接标记true，如果长的话那么再判断中间是否也是回文串。

● 516.最长回文子序列

dp，先创建dp数组，然后第一遍倒序，第二遍正序，从下到上，从左到右遍历，然后如果i==j比对上，那么代表找到回文串头尾，长度就是i+1 j-1的dp+2，也就是中间的长度加上头尾。

LC5最长回文子串

两种做法

中心扩散法，跟647类似不过扩散的时候要记录长度和起始点，以便于最后找最长子串。

dp：

```
/**
O(N^2), O(N^2)

用boolean dp[i][j]来表示s[i : j]是否为合法回文子串
初始化：所有长度为1的子串都是回文子串
递推：先枚举长度，从2开始，因为长度为1已经确立，然后从下标0开始枚举左边界，左边界加上长度-1就是右边界
如果右边界越界，那么退出循环
dp公式：
if(s.charAt(i) == s.charAt(j)){
    if(i - j < 3) dp[i][j] = true;
    else dp[i][j] = dp[i + 1][j - 1];
}
else dp[i][j] = false;
如果dp[i][j]成立，更新最大长度为max或者当前L，然后更新其实下标为i
 */
```
